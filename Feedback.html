<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link id="favicon" rel="icon" href="./assets/favicon.png">

  <!-- =================================================================================== -->
  <!-- =========================== CONFIGURATION DE L'APPLICATION ====================== -->
  <!-- =================================================================================== -->
  <script id="app-config">
    /*
     * Configurez votre application ici.
     */
    const APP_CONFIG = {
      // --- Backend URL ---
      // L'URL de votre script Google Apps Script (obtenue après le déploiement).
      WEBAPP_URL: "https://script.google.com/macros/s/AKfycbzzdlfCuqikvYDSUlwsKvIrUL59pCWoxETr-jKM4_GmQj2I4rdscHgevJQgBM2NqA/exec",

      // --- Branding ---
      // Utilisez des chemins relatifs (ex: ./assets/logo.png) si les images sont
      // dans le même dépôt, ou des URLs complètes (https://...) si elles sont hébergées ailleurs.
      BRAND: {
        TITLE: "Feedback CHOPS",
        LOGO_URL: "./assets/logo.png", // Image pour l'en-tête
        MARK_URL: "Chops/CHOPiBasic.svg", // Icône pour les cartes
        FAVICON_URL: "Chops/CHOPiBasic.svg" // Icône pour l'onglet
      },

      // --- Limites d'enregistrement ---
      LIMITS: {
        MAX_SECONDS: 120, // Durée maximale en secondes (120s = 2 minutes)
        MAX_BYTES: 10 * 1024 * 1024, // 10MB
      },

      // --- Questions par Profil ---
      // C'est ici que vous définissez les questions.
      // Chaque clé (ex: "declic") doit exister pour CHAQUE profil.
      QUESTIONS: {
        // Profil: etudiant
        etudiant: {
          declic: "En tant qu'étudiant, quel a été le 'déclic' ou le moment 'aha' où vous avez saisi l'utilité de CHOPS ?",
          usage: "Comment avez-vous concrètement utilisé CHOPS ou CHOPi pour un projet académique ou personnel ?",
          clarte: "Qu'est-ce qui a le plus clarifié votre compréhension du framework ? (ex: un cours, un exemple, CHOPi...)",
          equipe: "Si vous l'avez utilisé en groupe, comment CHOPS a-t-il structuré vos échanges ou votre travail d'équipe ?",
          CHOPi: "Dans votre parcours d'apprentissage, qu'est-ce qui vous a plu ou manqué dans l'outil CHOPi ?",
          reutilisation: "Pensez-vous réutiliser CHOPS à l'avenir ? Si oui, dans quel type de projet ou de contexte ?",
          libre: "Vous avez la parole : quel est le retour le plus important que vous aimeriez nous donner ?"
        },
        // Profil: entrepreneur
        entrepreneur: {
          declic: "En tant qu'entrepreneur, quel problème concret pensiez-vous résoudre ou quel 'déclic' avez-vous eu avec CHOPS ?",
          usage: "Comment avez-vous appliqué CHOPS ou CHOPi sur un de vos projets ou 'use case' d'entreprise ?",
          clarte: "Qu'est-ce qui, dans le framework, a le plus aidé à clarifier votre vision stratégique ou celle de vos équipes ?",
          equipe: "Comment vos équipes (ou vous-même) ont-elles interagi avec la méthode ? Quels ont été les points de friction ou de fluidité ?",
          CHOPi: "En tant que décideur, qu'avez-vous pensé de l'outil CHOPi ? Qu'est-ce qui lui manque pour être un outil pro ?",
          reutilisation: "Voyez-vous un potentiel de réutilisation de CHOPS pour d'autres 'use cases' dans votre organisation ?",
          libre: "Vous avez la parole : quel est le retour leF plus stratégique que vous aimeriez nous donner ?"
        },
        // Profil: freelance
        freelance: {
          declic: "En tant que freelance, quel a été le 'déclic' où vous vous êtes dit 'tiens, CHOPS pourrait m'aider avec mes clients' ?",
          usage: "Avez-vous pu utiliser CHOPS ou CHOPi (même mentalement) pour cadrer la mission d'un client ou un projet personnel ?",
          clarte: "Quelle partie du framework vous semble la plus utile pour structurer et vendre vos prestations de conseil ou de production ?",
          equipe: "En travaillant (souvent seul ou en petite équipe), comment CHOPS vous aide-t-il à mieux dialoguer avec vos clients/partenaires ?",
          CHOPi: "En tant qu'indépendant, que vous a-t-il plu ou manqué dans l'outil CHOPi pour vos propres besoins ?",
          reutilisation: "Pensez-vous intégrer CHOPS à votre 'stack' d'outils méthodologiques pour vos futures missions ?",
          libre: "Vous avez la parole : quel est le retour le plus pertinent que vous aimeriez nous donner ?"
        },
        // Profil: enseignant
        enseignant: {
          declic: "En tant qu'enseignant, quel 'déclic' pédagogique avez-vous eu en découvrant le framework CHOPS ?",
          usage: "Comment avez-vous concrètement utilisé CHOPS ou CHOPi dans un de vos cours ou ateliers ?",
          clarte: "Du point de vue de l'enseignant, qu'est-ce qui vous semble le plus efficace pour transmettre ce framework aux étudiants ?",
          equipe: "Comment vos étudiants ont-ils réagi à la méthode ? Qu'est-ce qui a bien fonctionné ou non en classe ?",
          CHOPi: "Qu'avez-vous pensé de l'outil CHOPi comme support pédagogique ? Que lui manque-t-il ?",
          reutilisation: "Pensez-vous réutiliser CHOPS dans votre programme de cours à l'avenir ? Si oui, comment ?",
          libre: "Vous avez la parole : quel est le retour pédagogique le plus important que vous aimeriez nous donner ?"
        },
        // Profil: autre
        autre: {
          declic: "Dans votre contexte particulier, quel a été le 'déclic' ou le moment 'aha' où vous avez saisi l'utilité de CHOPS ?",
          usage: "Comment avez-vous concrètement utilisé CHOPS ou CHOPi dans votre projet ?",
          clarte: "Qu'est-ce qui a le plus clarifié votre compréhension du framework ?",
          equipe: "Si vous l'avez utilisé en groupe, comment CHOPS a-t-il structuré vos échanges ou votre travail ?",
          CHOPi: "Dans votre situation, qu'est-ce qui vous a plu ou manqué dans l'outil CHOPi ?",
          reutilisation: "Pensez-vous réutiliser CHOPS à l'avenir ? Si oui, dans quel type de projet ou de contexte ?",
          libre: "Vous avez la parole : quel est le retour le plus important que vous aimeriez nous donner ?"
        }
      }
    };
  </script>
  <!-- =================================================================================== -->
  <!-- ============================= FIN DE LA CONFIGURATION =========================== -->
  <!-- =================================================================================== -->

  <title id="appTitle">CHOPS – Retour vocal</title>
  <meta name="description" content="Mini-Voiceform CHOPS — collecte sécurisée de retours vocaux.">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --bg-start: #f3f4f6; /* Gris très clair */
      --bg-end: #e0e7ff;   /* Lavande pâle */
      --bg-mid: #dbeafe;  /* Bleu très pâle */
      
      --card-bg: rgba(255, 255, 255, 0.45);
      --card-border: rgba(255, 255, 255, 0.7);
      --card-shadow: rgba(0, 0, 0, 0.05);

      --text-primary: #111827;
      --text-secondary: #4b5563;
      
      --accent-primary: #4f46e5; /* Indigo */
      --accent-primary-hover: #4338ca;
      --accent-success: #16a34a; /* Vert */
      --accent-record: #dc2626; /* Rouge */
      --accent-pause: #f59e0b; /* Ambre */
    }

    /* Fond animé "Liquid Glass" */
    body {
      background: linear-gradient(-45deg, var(--bg-start), var(--bg-mid), var(--bg-end), var(--bg-mid));
      background-size: 400% 400%;
      animation: gradientBG 25s ease infinite;
      color: var(--text-primary);
      padding-bottom: 80px; /* Espace pour la barre de progression flottante */
    }
    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Style "Bulle" Frosted Glass */
    .glass-bubble {
      background-color: var(--card-bg);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border: 1px solid var(--card-border);
      box-shadow: 0 8px 32px 0 var(--card-shadow);
      transition: all 0.3s ease;
    }
    
    /* Inputs de formulaire */
    .form-input {
      background-color: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(209, 213, 219, 0.8);
      color: var(--text-primary);
    }
    .form-input:focus {
      background-color: rgba(255, 255, 255, 0.9);
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px var(--accent-primary);
      outline: none;
    }

    /* Boutons */
    .btn { @apply px-5 py-2 font-semibold rounded-full shadow-sm transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2; }
    .btn-primary { @apply bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500; }
    .btn-secondary { @apply bg-white text-indigo-600 border border-indigo-200 hover:bg-indigo-50 focus:ring-indigo-500; }
    .btn-record { @apply bg-red-600 text-white hover:bg-red-700 focus:ring-red-500; }
    .btn-pause { @apply bg-amber-500 text-white hover:bg-amber-600 focus:ring-amber-500; }
    .btn-disabled { @apply opacity-50 cursor-not-allowed; }

    /* Barre de progression flottante */
    #floatingProgress {
      background-color: var(--card-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-top: 1px solid var(--card-border);
      transition: opacity 0.3s, transform 0.3s;
    }

    /* Barre de progression animée */
    .progress-bar-inner {
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-success));
      background-size: 200% 100%;
      animation: progress-active 2s ease-in-out infinite;
      transition: width 0.5s cubic-bezier(0.25, 1, 0.5, 1);
    }
    @keyframes progress-active {
      0% { background-position: 100% 0; }
      100% { background-position: -100% 0; }
    }

    /* Masqué */
    .hidden { display: none; }
  </style>
</head>
<body class="min-h-screen font-sans antialiased">
  
  <!-- En-tête -->
  <header class="max-w-5xl mx-auto px-4 pt-6 pb-3 flex items-center justify-between gap-3">
    <div class="flex items-center gap-3">
      <img id="brandLogo" src="https://placehold.co/120x40/f0f0f0/333?text=Logo" alt="Logo" class="h-10 w-auto">
      <h1 id="brandTitle" class="text-xl font-semibold text-gray-800 hidden sm:block">CHOPS – Retour vocal</h1>
    </div>
    <button id="editProfileBtn" class="hidden text-sm font-medium text-indigo-600 hover:text-indigo-800">
      Modifier le profil
    </button>
  </header>

  <!-- Contenu Principal (Cartes) -->
  <main id="mainContent" class="max-w-5xl mx-auto p-4 space-y-6 opacity-0 transition-opacity duration-500">
    <div id="cardsHelperText" class="text-center text-gray-500 px-4 py-8">
      <p>Veuillez d'abord renseigner vos informations pour afficher les questions.</p>
    </div>
    
    <div id="cardsGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
      <!-- Les cartes de questions seront injectées ici par le script -->
    </div>
  </main>

  <!-- Barre de progression flottante -->
  <div id="floatingProgress" class="fixed bottom-0 left-0 right-0 p-4 shadow-lg">
    <div class="max-w-5xl mx-auto">
      <div class="flex items-center justify-between mb-1">
        <p id="progressText" class="text-sm font-medium text-gray-700" aria-live="polite">0/0 complétées</p>
        <span id="progressPct" class="text-sm font-semibold text-indigo-600">0%</span>
      </div>
      <div class="w-full h-2 rounded-full bg-gray-200 overflow-hidden">
        <div id="progressBar" class="progress-bar-inner h-2" style="width:0%"></div>
      </div>
    </div>
  </div>

  <!-- Notifications (Toasts) -->
  <div id="toasts" aria-live="polite" class="fixed top-5 right-5 z-50 w-full max-w-xs space-y-3"></div>

  <!-- =================================================================================== -->
  <!-- ==================================== MODALES ==================================== -->
  <!-- =================================================================================== -->

  <!-- Modale de Profil (Affichée au chargement) -->
  <div id="profileModal" class="fixed inset-0 z-40 flex items-center justify-center p-4" role="dialog" aria-modal="true" aria-labelledby="profileModalTitle">
    <div class="fixed inset-0 bg-gray-900/30 backdrop-blur-sm" aria-hidden="true"></div>
    
    <div class="glass-bubble relative w-full max-w-2xl rounded-2xl p-6 sm:p-8 space-y-6">
      <h2 id="profileModalTitle" class="text-2xl font-bold text-gray-900">Vos informations</h2>
      <p class="text-sm text-gray-600">Pour personnaliser les questions, veuillez renseigner les champs ci-dessous.</p>
      
      <!-- CORRECTION: Rétablissement du 'submit' listener sur le formulaire -->
      <form id="metaForm" class="space-y-5" novalidate>
        <fieldset class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label for="studentCode" class="block text-sm font-medium">Identifiant</label>
            <input id="studentCode" name="studentCode" placeholder="ID_Exemple" class="form-input mt-1 w-full rounded-lg px-3 py-2" required maxlength="32" inputmode="text" pattern="[A-Za-z0-9_\-]+">
            <p class="mt-1 text-xs text-gray-500">Un pseudo ou identifiant (ex: ID étudiant).</p>
          </div>
          <div>
            <label for="cohort" class="block text-sm font-medium">Contexte</label>
            <input id="cohort" name="cohort" placeholder="Ex : 3A, Startup X, Lycée Y…" class="form-input mt-1 w-full rounded-lg px-3 py-2" required>
             <p class="mt-1 text-xs text-gray-500">Votre promo, entreprise, établissement...</p>
          </div>
          <div>
            <label for="profile" class="block text-sm font-medium">Profil</label>
            <select id="profile" name="profile" class="form-input mt-1 w-full rounded-lg px-3 py-2">
              <option value="etudiant" selected>Étudiant</option>
              <option value="entrepreneur">Entrepreneur</option>
              <option value="freelance">Freelance</option>
              <option value="enseignant">Enseignant</option>
              <option value="autre">Autre</option>
            </select>
          </div>
          <div>
            <label for="used" class="block text-sm font-medium">Usage de CHOPS</label>
            <select id="used" name="used" class="form-input mt-1 w-full rounded-lg px-3 py-2">
              <option value="CHOPS_only">CHOPS (méthode)</option>
              <option value="CHOPS_plus_CHOPi">CHOPS + CHOPi (outil IA)</option>
              <option value="none">Aucun des deux</option>
            </select>
          </div>
        </fieldset>
        
        <fieldset class="space-y-3 pt-2">
          <legend class="text-sm font-medium">Consentement RGPD</legend>
          <label class="flex items-start gap-3 p-3 rounded-lg bg-white/50 border border-white/80">
            <input id="consent" type="checkbox" class="mt-1 h-5 w-5 rounded text-indigo-600 focus:ring-indigo-500">
            <span class="text-sm text-gray-700">J’accepte le stockage privé sur Google Drive (audio + transcription) et l’usage pédagogique/anonymisé de ces données. Vous pouvez demander la suppression à tout moment.</span>
          </label>
        </fieldset>

        <div class="text-right pt-2">
          <!-- CORRECTION: Changé type="button" en type="submit" -->
          <button id="saveProfileBtn" type="submit" class="btn btn-primary">Valider et commencer</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modale d'enregistrement -->
  <div id="recordModal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="fixed inset-0 bg-gray-900/30 backdrop-blur-sm" aria-hidden="true"></div>
    
    <div class="glass-bubble relative w-full max-w-xl rounded-2xl shadow-xl">
      <div class="flex items-start justify-between p-4 border-b border-white/50">
        <div>
          <p id="modalTheme" class="text-xs uppercase tracking-wide font-semibold text-indigo-700"></p>
          <h3 id="modalTitle" class="text-lg font-semibold text-gray-900"></h3>
        </div>
        <button id="modalClose" class="btn btn-secondary !p-2 !rounded-full !shadow-none" aria-label="Fermer">
          <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
        </button>
      </div>
      
      <div class="p-4 sm:p-6 space-y-5">
        <div id="controlsWrap" class="flex flex-col sm:flex-row items-center gap-3">
          <!-- Boutons Enregistrer / Pause / Reprendre -->
          <button id="btnRecord" type="button" class="btn btn-record w-full sm:w-auto">
            <span class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" /><path d="M5.5 8.5a.5.5 0 011 0V10a2 2 0 104 0V8.5a.5.5 0 011 0v1.5a3 3 0 11-6 0V8.5z" /><path d="M9 14a1 1 0 001 1h0a1 1 0 001-1v-1a1 1 0 00-1-1h0a1 1 0 00-1 1v1z" /></svg>
              Enregistrer
            </span>
          </button>
          <button id="btnPause" type="button" class="btn btn-pause w-full sm:w-auto hidden">
            <span class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.5 3.5A1.5 1.5 0 017 5v10a1.5 1.5 0 01-3 0V5a1.5 1.5 0 011.5-1.5zM12.5 3.5A1.5 1.5 0 0114 5v10a1.5 1.5 0 01-3 0V5a1.5 1.5 0 011.5-1.5z" clip-rule="evenodd" /></svg>
              Pause
            </span>
          </button>
          <button id="btnResume" type="button" class="btn btn-record w-full sm:w-auto hidden">
            <span class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" /><path d="M5.5 8.5a.5.5 0 011 0V10a2 2 0 104 0V8.5a.5.5 0 011 0v1.5a3 3 0 11-6 0V8.5z" /><path d="M9 14a1 1 0 001 1h0a1 1 0 001-1v-1a1 1 0 00-1-1h0a1 1 0 00-1 1v1z" /></svg>
              Reprendre
            </span>
          </button>
          
          <!-- Bouton Stop -->
          <button id="btnStop" type="button" class="btn btn-secondary w-full sm:w-auto" disabled>
             <span class="flex items-center justify-center gap-2">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 3.5A1.5 1.5 0 016.5 2h7A1.5 1.5 0 0115 3.5v7a1.5 1.5 0 01-1.5 1.5h-7A1.5 1.5 0 015 10.5v-7z" clip-rule="evenodd" /></svg>
              Stop
            </span>
          </button>

          <!-- Timer & Vumètre -->
          <div class="flex-1 w-full pt-2 sm:pt-0">
            <div class="h-2 rounded-full bg-white/60 overflow-hidden"><div id="meter" class="h-2 bg-green-500 transition-all duration-75" style="width:0%"></div></div>
            <p class="mt-1 text-xs text-gray-600 text-right"><span id="timer">00:00</span> / 02:00</p>
          </div>
        </div>
        
        <!-- Prévisualisation & Transcription -->
        <div id="previewWrap" class="hidden space-y-4">
          <button id="btnReRecord" type="button" class="text-sm font-medium text-indigo-600 hover:text-indigo-800">
            ↺ Réenregistrer
          </button>
          <audio id="player" controls class="w-full"></audio>
          <div id="transcriptionWrap" class="p-3 rounded-lg bg-white/60 border border-white/80">
            <p class="text-xs font-medium text-gray-500 mb-1">Transcription (auto)</p>
            <p id="transcriptionText" class="text-sm text-gray-700 italic">Génération de la transcription...</p>
          </div>
          <p id="fileInfo" class="mt-1 text-xs text-gray-500"></p>
        </div>
      </div>
      
      <!-- Footer Modale -->
      <div class="p-4 border-t border-white/50 flex items-center justify-between">
        <p class="text-xs text-gray-500">État : <span id="status">Prêt</span></p>
        <button id="btnSend" class="btn btn-primary btn-disabled" disabled>
          Envoyer cette réponse
        </button>
      </div>
    </div>
  </div>

  <script>
    // Configuration globale chargée depuis le <head>
    const CONFIG = window.APP_CONFIG || {};

    // Micro-fonction de sélection
    const $ = (selector) => document.querySelector(selector);
    const $$ = (selector) => document.querySelectorAll(selector);

    /* =================================================================================== */
    /* ============================== NOTIFICATIONS (TOASTS) =========================== */
    /* =================================================================================== */
    
    /**
     * Affiche une notification (toast).
     * @param {string} msg Le message à afficher.
     * @param {'info'|'ok'|'warn'|'err'} type Le type de toast (couleur).
     */
    function toast(msg, type = 'info') {
      const w = $('#toasts');
      const d = document.createElement('div');
      let c = 'bg-gray-700'; // info
      if (type === 'ok') c = 'bg-green-600';
      if (type === 'warn') c = 'bg-amber-500';
      if (type === 'err') c = 'bg-red-600';
      
      d.className = `${c} text-white rounded-xl px-4 py-3 mb-2 shadow-lg text-sm font-medium transition-all duration-300 transform translate-x-full opacity-0`;
      d.textContent = msg;
      w.appendChild(d);
      
      // Animation d'apparition
      setTimeout(() => {
        d.classList.remove('translate-x-full', 'opacity-0');
        d.classList.add('translate-x-0', 'opacity-100');
      }, 10);

      // Animation de disparition
      setTimeout(() => {
        d.classList.add('translate-x-full', 'opacity-0');
        d.addEventListener('transitionend', () => d.remove());
      }, 3500);
    }

    /* =================================================================================== */
    /* ============================= GESTION DU LOCAL STORAGE ========================== */
    /* =================================================================================== */

    const LS_KEYS = {
      META: 'chops_voiceform_meta',
      STATUS_PREFIX: 'chops_voiceform_status_'
    };

    /** Enregistre les métadonnées de profil */
    function saveMeta(meta) {
      localStorage.setItem(LS_KEYS.META, JSON.stringify(meta));
    }
    
    /** Charge les métadonnées de profil */
    function loadMeta() {
      try {
        return JSON.parse(localStorage.getItem(LS_KEYS.META) || '{}');
      } catch (e) {
        return {};
      }
    }

    /** Enregistre le statut des réponses pour un identifiant */
    function saveStatus(studentId, status) {
      if (!studentId) return;
      localStorage.setItem(LS_KEYS.STATUS_PREFIX + studentId, JSON.stringify(status));
    }

    /** Charge le statut des réponses pour un identifiant */
    function loadStatus(studentId) {
      if (!studentId) return {};
      try {
        return JSON.parse(localStorage.getItem(LS_KEYS.STATUS_PREFIX + studentId) || '{}');
      } catch (e) {
        return {};
      }
    }
    
    /* =================================================================================== */
    /* =========================== LOGIQUE D'APPLICATION PRINCIPALE ====================== */
    /* =================================================================================== */

    document.addEventListener('DOMContentLoaded', () => {
      // --- Sélecteurs principaux ---
      const profileModal = $('#profileModal');
      const metaForm = $('#metaForm');
      const saveProfileBtn = $('#saveProfileBtn'); // Garder la référence même si on n'écoute plus le clic
      const editProfileBtn = $('#editProfileBtn');
      const mainContent = $('#mainContent');
      const cardsGrid = $('#cardsGrid');
      const cardsHelperText = $('#cardsHelperText');
      
      const recordModal = $('#recordModal');
      const modalClose = $('#modalClose');
      const statusEl = $('#status');
      
      const floatingProgress = $('#floatingProgress');
      const progressText = $('#progressText');
      const progressPct = $('#progressPct');
      const progressBar = $('#progressBar');

      // --- État de l'application ---
      let currentMeta = { studentCode: '', cohort: '', profile: 'etudiant', used: 'CHOPS_plus_CHOPi', consent: false };
      let currentStatus = {};
      let topics = [];
      let currentTopic = null;
      let lastTrigger = null;
      let sending = false;
      let currentAnimatedPct = 0;
      let isSubmittingProfile = false; // Flag pour éviter double soumission

      // --- Branding ---
      $('#appTitle').textContent = CONFIG.BRAND.TITLE;
      $('#brandTitle').textContent = CONFIG.BRAND.TITLE;
      $('#brandLogo').src = CONFIG.BRAND.LOGO_URL;
      $('#favicon').href = CONFIG.BRAND.FAVICON_URL;

      // ------------------------------------
      // Initialisation du profil
      // ------------------------------------
      
      /**
       * Charge le profil depuis le LS et remplit le formulaire.
       * Affiche la modale si le profil n'est pas valide.
       */
      function initProfile() {
        const meta = loadMeta();
        if (meta && meta.studentCode && meta.cohort && meta.consent) {
          currentMeta = meta;
          // Pré-remplir le formulaire
          $('#studentCode').value = meta.studentCode;
          $('#cohort').value = meta.cohort;
          $('#profile').value = meta.profile;
          $('#used').value = meta.used;
          $('#consent').checked = meta.consent;
          
          // Profil valide, on cache la modale et on charge les cartes
          profileModal.classList.add('hidden');
          mainContent.classList.remove('opacity-0');
          editProfileBtn.classList.remove('hidden');
          currentStatus = loadStatus(currentMeta.studentCode);
          renderAllCards();
        } else {
          // Profil invalide ou incomplet, on affiche la modale
          profileModal.classList.remove('hidden');
          mainContent.classList.add('opacity-0');
          editProfileBtn.classList.add('hidden');
        }
      }

      /**
       * Gère la soumission du formulaire de profil.
       */
      // CORRECTION : Écouter l'événement 'submit' du formulaire
      metaForm.addEventListener('submit', (e) => {
        e.preventDefault(); // Empêcher le rechargement de la page par défaut
        e.stopPropagation(); // Empêcher la propagation si nécessaire

        // Empêcher les soumissions multiples
        if (isSubmittingProfile) {
          console.log('Soumission déjà en cours, ignorée');
          return;
        }
        
        isSubmittingProfile = true;
        saveProfileBtn.disabled = true; // Désactiver le bouton pendant le traitement
        saveProfileBtn.classList.add('btn-disabled');

        const studentCode = $('#studentCode').value.trim();
        const cohort = $('#cohort').value.trim();
        const consent = $('#consent').checked;

        // Validation des champs
        if (!/^[A-Za-z0-9_\-]{1,32}$/.test(studentCode)) {
          toast('Identifiant invalide (lettres, chiffres, _, - uniquement).', 'warn');
          isSubmittingProfile = false; // Réactiver pour nouvelle tentative
          saveProfileBtn.disabled = false;
          saveProfileBtn.classList.remove('btn-disabled');
          return;
        }
        if (cohort.length < 1) {
          toast('Veuillez renseigner votre contexte.', 'warn');
          isSubmittingProfile = false;
          saveProfileBtn.disabled = false;
          saveProfileBtn.classList.remove('btn-disabled');
          return;
        }
        if (!consent) {
          toast('Le consentement est requis pour continuer.', 'warn');
          isSubmittingProfile = false;
          saveProfileBtn.disabled = false;
          saveProfileBtn.classList.remove('btn-disabled');
          return;
        }

        // Si tout est valide, mettre à jour l'état et l'UI
        currentMeta = {
          studentCode: studentCode,
          cohort: cohort,
          profile: $('#profile').value,
          used: $('#used').value,
          consent: true
        };
        
        saveMeta(currentMeta); // Sauvegarder dans localStorage
        currentStatus = loadStatus(currentMeta.studentCode); // Charger le statut pour cet utilisateur
        
        // Fermer la modale
        profileModal.classList.add('hidden');
        
        // Afficher le contenu principal et les cartes (avec un léger délai pour l'animation)
        setTimeout(() => {
          renderAllCards();
          mainContent.classList.remove('opacity-0');
          editProfileBtn.classList.remove('hidden');
          toast('Profil enregistré !', 'ok');
          
          isSubmittingProfile = false; // Réinitialiser le flag
          saveProfileBtn.disabled = false; // Réactiver le bouton
          saveProfileBtn.classList.remove('btn-disabled');
        }, 150); // Petit délai pour laisser le temps à la modale de disparaître
      });


      // Bouton pour rouvrir la modale de profil
      editProfileBtn.addEventListener('click', () => {
        profileModal.classList.remove('hidden');
      });

      // ------------------------------------
      // Rendu des cartes et progression
      // ------------------------------------

      /**
       * Obtient la question spécifique pour le profil et le sujet.
       * @param {string} profile - ex: 'etudiant'
       * @param {string} topic - ex: 'declic'
       * @returns {string} - La question formulée.
       */
      function getQuestion(profile, topic) {
        try {
          // Essayer le profil spécifique, sinon 'autre', sinon message d'erreur
          const profileQuestions = CONFIG.QUESTIONS[profile] || CONFIG.QUESTIONS['autre'];
          return profileQuestions[topic] || "Question non définie.";
        } catch (e) {
          console.error(`Erreur getQuestion(${profile}, ${topic})`, e);
          return "Question non disponible.";
        }
      }
      
      /**
       * (Re)Génère toutes les cartes de questions.
       */
      function renderAllCards() {
        const profile = currentMeta.profile || 'autre';
        const profileQuestions = CONFIG.QUESTIONS[profile] || CONFIG.QUESTIONS['autre'];
        
        // Si même 'autre' n'existe pas, on arrête
        if (!profileQuestions) {
           console.error("Aucune question définie, même pour le profil 'autre'. Vérifiez APP_CONFIG.QUESTIONS.");
           topics = [];
           cardsHelperText.textContent = "Erreur de configuration des questions.";
           cardsHelperText.classList.remove('hidden');
           cardsGrid.innerHTML = '';
           updateProgress(); // Mettre à jour la progression à 0
           return;
        }

        topics = Object.keys(profileQuestions);

        if (topics.length === 0) {
          cardsHelperText.textContent = "Aucune question n'est configurée pour ce profil.";
          cardsHelperText.classList.remove('hidden');
          cardsGrid.innerHTML = '';
          updateProgress(); // Mettre à jour la progression à 0
          return;
        }

        cardsHelperText.classList.add('hidden');
        cardsGrid.innerHTML = ''; // Vider la grille

        topics.forEach(topic => {
          const entry = currentStatus[topic];
          const done = !!entry?.done;
          const questionText = getQuestion(profile, topic);
          
          const card = document.createElement('button');
          card.type = 'button';
          card.dataset.topic = topic;
          // Style conditionnel pour l'opacité si la carte est faite
          card.className = `glass-bubble w-full text-left rounded-xl p-5 space-y-3 transition duration-200 hover:shadow-lg hover:-translate-y-1 ${done ? 'opacity-70 hover:opacity-100' : ''}`;
          
          card.innerHTML = `
            <div class="flex items-center justify-between">
              <span class="flex items-center gap-2 text-sm font-semibold text-indigo-700">
                <img src="${CONFIG.BRAND.MARK_URL}" alt="" class="h-5 w-5">
                ${topic.charAt(0).toUpperCase() + topic.slice(1)} 
              </span>
              ${done
                ? `<span class="px-2 py-0.5 rounded-full bg-green-100 text-green-700 text-xs font-medium">Répondu</span>`
                : `<span class="px-2 py-0.5 rounded-full bg-gray-100 text-gray-600 text-xs font-medium">À faire</span>`
              }
            </div>
            <p class="text-sm text-gray-800">${questionText}</p>
            ${done && entry.at ? `<p class="text-xs text-gray-500 pt-2">Répondu le ${new Date(entry.at).toLocaleDateString()}</p>` : ''}
          `;
          
          card.addEventListener('click', () => openModal(topic, card));
          cardsGrid.appendChild(card);
        });

        updateProgress();
      }

      /**
       * Met à jour la barre de progression (fixe et flottante).
       */
      function updateProgress() {
        const done = topics.filter(t => !!currentStatus[t]?.done).length;
        const total = topics.length;
        const pct = (total > 0) ? Math.round((done / total) * 100) : 0;
        
        progressText.textContent = `${done}/${total} complétées`;
        
        // Animer le pourcentage
        animateCounter(progressPct, currentAnimatedPct, pct, '%');
        currentAnimatedPct = pct;

        progressBar.style.width = `${pct}%`;
      }
      
      /**
       * Anime un compteur de nombre.
       */
      function animateCounter(el, from, to, suffix = '') {
        if (!el) return; // Sécurité si l'élément n'existe pas
        if (from === to) {
          el.textContent = `${to}${suffix}`;
          return;
        }
        const duration = 400; // ms
        const frameRate = 1000 / 60; // 60 fps
        const totalFrames = Math.round(duration / frameRate);
        const diff = to - from;
        let frame = 0;

        const counter = setInterval(() => {
          frame++;
          // Utiliser une fonction d'easing (ex: easeOutQuad) pour un effet plus doux
          const progress = 1 - Math.pow(1 - (frame / totalFrames), 2); 
          const currentVal = from + (diff * progress);
          
          el.textContent = `${Math.round(currentVal)}${suffix}`;

          if (frame >= totalFrames) {
            clearInterval(counter);
            el.textContent = `${to}${suffix}`; // Assurer la valeur finale exacte
          }
        }, frameRate);
      }
      
      // ------------------------------------
      // Logique de la Modale d'Enregistrement
      // ------------------------------------
      
      const btnRecord = $('#btnRecord');
      const btnPause = $('#btnPause');
      const btnResume = $('#btnResume');
      const btnStop = $('#btnStop');
      const btnReRecord = $('#btnReRecord');
      const btnSend = $('#btnSend');
      
      const meterBar = $('#meter');
      const timerEl = $('#timer');
      const player = $('#player');
      const previewWrap = $('#previewWrap');
      const transcriptionWrap = $('#transcriptionWrap');
      const transcriptionText = $('#transcriptionText');
      const fileInfo = $('#fileInfo');

      let mediaStream, mediaRecorder, audioChunks = [], audioBlob = null, audioUrl = null, mimeType = 'audio/webm';
      let audioTranscription = ""; // Stocker la transcription
      let startedAt = 0, pausedAt = 0, totalPausedTime = 0;
      let timerInterval = null;
      let audioContext, analyser, dataArray;
      
      /** Ouvre la modale pour un sujet donné */
      function openModal(topic, trigger) {
        if (sending) {
          toast('Un envoi est déjà en cours...', 'warn');
          return;
        }
        // Vérifier si le profil est bien chargé (sécurité supplémentaire)
        if (!currentMeta.consent || !currentMeta.studentCode || !currentMeta.cohort) {
           toast('Veuillez d'abord valider votre profil.', 'warn');
           profileModal.classList.remove('hidden'); // Rouvrir la modale si besoin
           return;
        }
        
        currentTopic = topic;
        lastTrigger = trigger || null;
        
        $('#modalTheme').textContent = topic.charAt(0).toUpperCase() + topic.slice(1);
        $('#modalTitle').textContent = getQuestion(currentMeta.profile, topic);
        
        resetRecording(true); // Réinitialiser l'état d'enregistrement
        
        recordModal.classList.remove('hidden');
        btnRecord.focus(); // Mettre le focus sur le bouton d'enregistrement
      }

      /** Ferme la modale d'enregistrement */
      function closeModal() {
        // CORRECTION: Suppression du 'confirm()'
        // if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
        //   if (!confirm("Vous avez un enregistrement en cours. Voulez-vous vraiment l'annuler ?")) {
        //     return;
        //   }
        // }
        
        // Arrêter l'enregistrement et les flux s'ils sont actifs
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
        mediaStream?.getTracks().forEach(track => track.stop());
        
        recordModal.classList.add('hidden'); // Cacher la modale
        
        // Renvoyer le focus à l'élément qui a ouvert la modale
        if (lastTrigger) {
          lastTrigger.focus();
        }
      }
      modalClose.addEventListener('click', closeModal);
      // Fermer aussi si on clique en dehors de la modale
      recordModal.addEventListener('click', (e) => {
        if (e.target === recordModal) {
            closeModal();
        }
      });
      // Fermer avec la touche Echap
      document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && !recordModal.classList.contains('hidden')) {
              closeModal();
          }
      });
      
      /** Met à jour le texte de statut */
      function setStatus(t) { statusEl.textContent = t; }
      
      /** Formate les secondes en MM:SS */
      function hhmmss(s) {
        const sec = Math.max(0, Math.floor(s)); // Assurer que le temps n'est pas négatif
        return `${String(Math.floor(sec / 60)).padStart(2, '0')}:${String(sec % 60).padStart(2, '0')}`;
      }
      
      /** Met à jour l'état (activé/désactivé) du bouton d'envoi */
      function updateSendState() {
        const canSend = currentMeta.consent && !!audioBlob && !sending;
        btnSend.disabled = !canSend;
        btnSend.classList.toggle('btn-disabled', !canSend);
      }

      /** Réinitialise l'interface d'enregistrement */
      function resetRecording(inModal = false) {
        // Arrêter les flux et le contexte audio proprement
        mediaStream?.getTracks().forEach(t => t.stop());
        mediaStream = null;
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          // Éviter d'appeler stop() si déjà arrêté, peut causer des erreurs
          try { mediaRecorder.stop(); } catch(e) { console.warn("Arrêt redondant du recorder"); }
        }
        mediaRecorder = null;
        audioContext?.close().catch(e => console.warn("Erreur fermeture AudioContext"));
        audioContext = null;
        
        clearInterval(timerInterval);
        timerInterval = null;
        
        audioChunks = [];
        audioBlob = null;
        audioTranscription = "";
        if (audioUrl) {
           URL.revokeObjectURL(audioUrl); // Libérer la mémoire
           audioUrl = null;
        }
        
        startedAt = 0;
        pausedAt = 0;
        totalPausedTime = 0;
        
        if (inModal) {
          previewWrap.classList.add('hidden'); // Cacher la prévisualisation
          transcriptionWrap.classList.add('hidden'); // Cacher la transcription
          transcriptionText.textContent = "Génération de la transcription..."; // Texte par défaut
          timerEl.textContent = '00:00'; // Remettre le timer à zéro
          meterBar.style.width = '0%'; // Remettre le vumètre à zéro
          
          // Afficher le bouton Enregistrer, cacher Pause/Reprendre
          btnRecord.classList.remove('hidden');
          btnPause.classList.add('hidden');
          btnResume.classList.add('hidden');
          btnStop.disabled = true; // Désactiver Stop
          
          btnRecord.disabled = false; // Activer Enregistrer
          
          setStatus('Prêt'); // Mettre le statut à "Prêt"
          updateSendState(); // Mettre à jour l'état du bouton Envoyer
        }
      }

      // --- Logique d'enregistrement ---
      
      btnRecord.addEventListener('click', startRecording);
      btnPause.addEventListener('click', pauseRecording);
      btnResume.addEventListener('click', resumeRecording);
      btnStop.addEventListener('click', stopRecording);
      btnReRecord.addEventListener('click', () => {
         // CORRECTION: Suppression du 'confirm()'
         // if (audioBlob) {
         //     if (!confirm("Voulez-vous vraiment effacer l'enregistrement actuel pour en faire un nouveau ?")) {
         //         return;
         //     }
         // }
         resetRecording(true); // Réinitialiser pour un nouvel enregistrement
      });

      /** Démarre l'enregistrement */
      async function startRecording() {
        resetRecording(true); // Assure un état propre avant de démarrer
        try {
          // Demander accès au micro
          mediaStream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
              // Options pour améliorer la qualité si supporté (optionnel)
              noiseSuppression: true,
              echoCancellation: true
            } 
          });
        } catch (err) {
          console.error("Erreur getUserMedia:", err);
          let errorMsg = 'Erreur : Micro refusé ou non trouvé.';
          if (err.name === 'NotAllowedError') {
            errorMsg = 'Vous devez autoriser l\'accès au microphone dans votre navigateur.';
          } else if (err.name === 'NotFoundError') {
             errorMsg = 'Aucun microphone n\'a été trouvé sur votre appareil.';
          }
          toast(errorMsg, 'err');
          setStatus('Erreur micro');
          return;
        }

        try {
          // Initialiser le contexte audio pour le vumètre
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256; // Précision du vumètre
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          const source = audioContext.createMediaStreamSource(mediaStream);
          source.connect(analyser); // Connecter le micro à l'analyseur

          // Choisir le meilleur format d'enregistrement supporté
          const preferred = ["audio/webm;codecs=opus", "audio/webm", "audio/mp4", "audio/ogg;codecs=opus"];
          mimeType = preferred.find(t => MediaRecorder.isTypeSupported?.(t)) || 'audio/webm'; // Fallback
          
          mediaRecorder = new MediaRecorder(mediaStream, { mimeType });

          // Stocker les données audio au fur et à mesure
          mediaRecorder.ondataavailable = e => {
            if (e.data && e.data.size > 0) audioChunks.push(e.data);
          };

          // Actions au démarrage
          mediaRecorder.onstart = () => {
            startedAt = Date.now();
            totalPausedTime = 0;
            setStatus('Enregistrement en cours…');
            toast('Enregistrement démarré...');
            
            // Mise à jour de l'UI des boutons
            btnRecord.classList.add('hidden');
            btnPause.classList.remove('hidden');
            btnResume.classList.add('hidden');
            btnStop.disabled = false; // Activer Stop
            
            // Démarrer le timer et le vumètre
            if (timerInterval) clearInterval(timerInterval); // Sécurité
            timerInterval = setInterval(() => {
              // Calculer le temps écoulé en tenant compte des pauses
              const elapsedSeconds = (Date.now() - startedAt - totalPausedTime) / 1000;
              const sec = Math.min(CONFIG.LIMITS.MAX_SECONDS, elapsedSeconds);
              timerEl.textContent = hhmmss(sec); // Mettre à jour l'affichage du timer
              
              // Arrêt automatique si le temps max est atteint
              if (sec >= CONFIG.LIMITS.MAX_SECONDS) {
                stopRecording();
                toast(`Temps maximum (${hhmmss(CONFIG.LIMITS.MAX_SECONDS)}) atteint.`, 'warn');
              }
              
              // Mettre à jour le vumètre
              if (analyser && dataArray) {
                analyser.getByteTimeDomainData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                  const v = (dataArray[i] - 128) / 128; // Normaliser entre -1 et 1
                  sum += v * v; // Somme des carrés
                }
                const rms = Math.sqrt(sum / dataArray.length); // Root Mean Square (volume)
                // Ajuster le multiplicateur pour une meilleure visualisation
                meterBar.style.width = Math.min(100, Math.floor(rms * 200)) + "%"; 
              }
            }, 80); // Rafraîchir toutes les 80ms
          };
          
          // Actions à l'arrêt de l'enregistrement
          mediaRecorder.onstop = () => {
            clearInterval(timerInterval); // Arrêter le timer/vumètre
            timerInterval = null;
            meterBar.style.width = '0%'; // Remettre le vumètre à zéro
            
            // Créer le fichier audio final (Blob)
            audioBlob = new Blob(audioChunks, { type: mimeType });
            
            // Vérifier la taille du fichier
            if (audioBlob.size > CONFIG.LIMITS.MAX_BYTES) {
              toast(`Fichier trop volumineux (> ${Math.round(CONFIG.LIMITS.MAX_BYTES / 1024 / 1024)} Mo). Veuillez réenregistrer.`, 'err');
              resetRecording(true); // Réinitialiser
              return;
            }
            
            // Vérifier la durée minimale (ex: 1 seconde = ~1000 bytes)
            if (audioBlob.size < 1000) {
               toast('Enregistrement trop court. Veuillez parler plus longtemps.', 'warn');
               resetRecording(true); // Réinitialiser
               return;
            }

            // Afficher la prévisualisation
            audioUrl = URL.createObjectURL(audioBlob);
            player.src = audioUrl;
            previewWrap.classList.remove('hidden'); // Afficher la zone de prévisualisation
            transcriptionWrap.classList.remove('hidden'); // Afficher la zone de transcription
            fileInfo.textContent = `${mimeType}, ${(audioBlob.size / 1024).toFixed(1)} KB, durée: ${timerEl.textContent}`;
            
            setStatus('Transcription en cours...');
            btnRecord.disabled = true; // Désactiver Enregistrer pendant la transcription
            btnStop.disabled = true;  // Stop est déjà désactivé mais pour être sûr
            
            // Démarrer la transcription (appel asynchrone)
            transcribeAudio(audioBlob); 
            
            updateSendState(); // Mettre à jour l'état du bouton Envoyer (sera désactivé car sending=false)
            
            // Arrêter les flux et le contexte audio proprement
            mediaStream?.getTracks().forEach(t => t.stop());
            mediaStream = null;
            audioContext?.close().catch(e => console.warn("Erreur fermeture tardive AudioContext"));
            audioContext = null;
          };

          // Gérer les erreurs potentielles du MediaRecorder
          mediaRecorder.onerror = (event) => {
              console.error(`Erreur MediaRecorder: ${event.error.name}`, event.error);
              toast(`Erreur d'enregistrement: ${event.error.message}`, 'err');
              setStatus('Erreur enregistrement');
              resetRecording(true);
          };
          
          // Démarrer l'enregistrement (déclenche onstart)
          mediaRecorder.start();

        } catch (err) {
            console.error("Erreur lors de l'initialisation de l'enregistrement:", err);
            toast("Impossible de démarrer l'enregistrement.", 'err');
            setStatus('Erreur init');
            resetRecording(true); // Nettoyer en cas d'erreur
        }
      }
      
      /** Met l'enregistrement en pause */
      function pauseRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.pause(); // Mettre en pause l'enregistreur
          pausedAt = Date.now(); // Noter l'heure de la pause
          clearInterval(timerInterval); // Arrêter le timer/vumètre
          timerInterval = null;
          setStatus('En pause');
          
          // Mettre à jour l'UI des boutons
          btnPause.classList.add('hidden');
          btnResume.classList.remove('hidden');
        }
      }
      
      /** Reprend l'enregistrement */
      function resumeRecording() {
        if (mediaRecorder && mediaRecorder.state === 'paused') {
          mediaRecorder.resume(); // Reprendre l'enregistrement
          // Ajouter le temps passé en pause au total des pauses
          totalPausedTime += (Date.now() - pausedAt); 
          pausedAt = 0; // Réinitialiser l'heure de pause
          setStatus('Enregistrement en cours…');
          
          // Mettre à jour l'UI des boutons
          btnPause.classList.remove('hidden');
          btnResume.classList.add('hidden');
          
          // Relancer l'intervalle du timer/vumètre (copié de onstart)
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            const elapsedSeconds = (Date.now() - startedAt - totalPausedTime) / 1000;
            const sec = Math.min(CONFIG.LIMITS.MAX_SECONDS, elapsedSeconds);
            timerEl.textContent = hhmmss(sec);
            if (sec >= CONFIG.LIMITS.MAX_SECONDS) stopRecording();
            if (analyser && dataArray) {
              analyser.getByteTimeDomainData(dataArray);
              let sum = 0;
              for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; }
              const rms=Math.sqrt(sum/dataArray.length);
              meterBar.style.width=Math.min(100,Math.floor(rms*200))+"%";
            }
          }, 80);
        }
      }
      
      /** Arrête l'enregistrement */
      function stopRecording() {
        // N'arrêter que si l'enregistrement est actif ou en pause
        if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
          mediaRecorder.stop(); // Déclenche l'événement 'onstop'
          toast('Enregistrement arrêté.');
          
          // Remettre l'UI dans l'état initial (pré-enregistrement)
          // Note: l'événement 'onstop' gérera l'affichage de la prévisualisation
          btnRecord.classList.remove('hidden'); // Afficher Enregistrer
          btnPause.classList.add('hidden');    // Cacher Pause
          btnResume.classList.add('hidden');   // Cacher Reprendre
          btnStop.disabled = true;             // Désactiver Stop
          btnRecord.disabled = false;          // Réactiver Enregistrer (sera désactivé pendant la transcription)
        }
      }

      // ------------------------------------
      // Logique d'Envoi et API
      // ------------------------------------

      /**
       * Wrapper Fetch sécurisé pour Google Apps Script (contournement CORS)
       * @param {string} url - URL du script GAS
       * @param {object} payload - Données à envoyer
       * @returns {Promise<object>} - La réponse JSON
       */
      async function fetchGAS(url, payload) {
        try {
          // CORRECTION "Failed to Fetch" (CORS)
          // On envoie en 'text/plain' pour éviter la pré-vérification OPTIONS
          const response = await fetch(url, {
            method: 'POST',
            mode: 'cors', // Important pour les requêtes cross-origin
            credentials: 'omit', // Ne pas envoyer de cookies
            headers: {
              // L'astuce CORS: prétendre envoyer du texte simple
              'Content-Type': 'text/plain;charset=utf-8', 
            },
            body: JSON.stringify(payload), // Le corps est bien du JSON
            redirect: 'follow' // Suivre les redirections si GAS en fait
          });

          if (!response.ok) {
            // Essayer de lire le message d'erreur du backend si possible
            let errorText = `Erreur réseau : ${response.statusText} (${response.status})`;
            try {
              const errorJson = await response.json();
              if (errorJson && errorJson.error) {
                 errorText = `Erreur backend : ${errorJson.error}`;
              }
            } catch(e) { /* Ignorer si la réponse n'est pas du JSON */ }
            throw new Error(errorText);
          }
          
          // Analyser la réponse JSON du backend
          const jsonResponse = await response.json();
          return jsonResponse; 

        } catch (err) {
           console.error("Erreur fetchGAS:", err);
           // Renvoyer une erreur plus générique au lieu de l'erreur brute
           throw new Error("La communication avec le serveur a échoué."); 
        }
      }

      /**
       * Convertit un Blob en Base64.
       * @param {Blob} blob - Le fichier audio.
       * @returns {Promise<string>} - La chaîne Base64 (sans le préfixe data:).
       */
      function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            try {
              const base64data = reader.result;
              // Extraire seulement la partie base64 après la virgule
              const base64 = base64data.split(',')[1];
              if (!base64) {
                 throw new Error("Conversion Base64 invalide.");
              }
              resolve(base64);
            } catch (err) {
               reject(err);
            }
          };
          reader.onerror = (error) => reject(error); // Gérer les erreurs de lecture
          reader.readAsDataURL(blob); // Lire le blob comme une URL de données
        });
      }

      /**
       * Appelle le backend pour transcrire l'audio.
       * @param {Blob} audioBlob - Le fichier audio.
       */
      async function transcribeAudio(audioBlob) {
        // Vérifier si l'URL du backend est configurée
        if (!CONFIG.WEBAPP_URL || CONFIG.WEBAPP_URL === "À_RENSEIGNER") {
          toast('Erreur: Le backend n\'est pas configuré (WEBAPP_URL).', 'err');
          setStatus('Erreur config');
          transcriptionText.textContent = "[Erreur de configuration backend]";
          // Permettre quand même l'envoi si la transcription échoue ? Oui.
          btnRecord.disabled = false; 
          updateSendState();
          return;
        }
        
        try {
          setStatus('Conversion audio...');
          const fileBase64 = await blobToBase64(audioBlob); // Convertir l'audio
          setStatus('Transcription en cours...');
          
          const payload = {
            action: "transcribe", // Action pour le backend
            mimeType: mimeType, // Type de fichier audio
            fileBase64: fileBase64 // Audio en base64
          };

          // Appeler le backend via notre fonction fetchGAS sécurisée
          const json = await fetchGAS(CONFIG.WEBAPP_URL, payload);

          // Vérifier la réponse du backend
          if (json.ok === false || typeof json.transcription !== 'string') {
            throw new Error(json.error || 'Réponse de transcription invalide reçue.');
          }

          audioTranscription = json.transcription || "[Transcription vide]"; // Stocker la transcription
          transcriptionText.textContent = audioTranscription; // Afficher
          setStatus('Prêt à l’envoi');
          toast('Transcription réussie.', 'ok');

        } catch (err) {
          console.error('Erreur de transcription:', err);
          // Afficher un message d'erreur plus utile à l'utilisateur
          toast(`La transcription a échoué (${err.message}). Vous pouvez quand même envoyer.`, 'err');
          setStatus('Erreur transcription');
          transcriptionText.textContent = `[Échec de la transcription. Vous pouvez quand même envoyer l'audio.]`;
          audioTranscription = "[TRANSCRIPTION_FAILED]"; // Marqueur d'échec
        } finally {
          // Réactiver les boutons même si la transcription échoue
          btnRecord.disabled = false;
          btnStop.disabled = true; // Stop reste désactivé après l'arrêt
          updateSendState(); // Mettre à jour l'état du bouton Envoyer
        }
      }
      
      // Attacher la fonction d'envoi au clic du bouton Envoyer
      btnSend.addEventListener('click', submitOne);

      /**
       * Envoie la réponse finale (audio + métadonnées + transcription).
       */
      async function submitOne() {
        // Empêcher les envois multiples ou si pas d'audio
        if (sending || !audioBlob) return; 
        
        // Vérifier à nouveau la configuration du backend
        if (!CONFIG.WEBAPP_URL || CONFIG.WEBAPP_URL === "À_RENSEIGNER") {
          toast('Erreur: Le backend n\'est pas configuré (WEBAPP_URL).', 'err');
          return;
        }

        sending = true; // Marquer comme "envoi en cours"
        setStatus('Envoi en cours…');
        updateSendState(); // Désactiver le bouton Envoyer
        toast('Envoi de votre réponse...');
        
        try {
          // Convertir l'audio en base64 (peut prendre un peu de temps)
          setStatus('Préparation de l\'envoi...');
          const fileBase64 = await blobToBase64(audioBlob);
          
          // Récupérer la durée finale
          const [mm, ss] = timerEl.textContent.split(':').map(Number);
          const durationSec = (mm * 60 + ss) || 0;

          // Préparer le payload complet pour le backend
          const payload = {
            action: "uploadAudio", // Action pour le backend
            ...currentMeta, // Inclure studentCode, cohort, profile, used, consent
            topic: currentTopic, // Le sujet de la question
            durationSec: durationSec, // Durée de l'audio
            mimeType: mimeType, // Type de fichier audio
            transcription: audioTranscription, // Transcription (ou marqueur d'échec)
            fileBase64: fileBase64, // L'audio lui-même
            clientUA: navigator.userAgent // Info sur le navigateur (optionnel)
          };

          setStatus('Envoi des données...');
          // Envoyer au backend
          const json = await fetchGAS(CONFIG.WEBAPP_URL, payload);

          // Vérifier la réponse du backend
          if (json.ok === false) {
            throw new Error(json.error || 'Erreur inconnue lors de l\'enregistrement.');
          }

          setStatus('Terminé ✅');
          toast('Réponse envoyée avec succès !', 'ok');
          
          // Mettre à jour le statut localement pour marquer comme "fait"
          currentStatus[currentTopic] = {
            done: true,
            at: new Date().toISOString(), // Date de l'envoi
            durationSec: durationSec // Stocker la durée
          };
          saveStatus(currentMeta.studentCode, currentStatus); // Sauvegarder dans localStorage
          
          renderAllCards(); // Mettre à jour l'affichage de la carte
          closeModal(); // Fermer la modale d'enregistrement

        } catch (err) {
          console.error('Erreur d\'envoi final:', err);
          // Afficher un message d'erreur clair
          toast(`Erreur d’envoi : ${err.message}. Veuillez réessayer.`, 'err');
          setStatus('Erreur d’envoi');
        } finally {
          sending = false; // Marquer comme "envoi terminé"
          updateSendState(); // Réactiver le bouton Envoyer si besoin
        }
      }

      // --- Démarrage ---
      // Lancer l'initialisation du profil au chargement de la page
      initProfile(); 
      
    }); // Fin de DOMContentLoaded
  </script>
</body>
</html>
